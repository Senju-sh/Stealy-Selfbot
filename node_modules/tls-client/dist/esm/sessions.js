import { request } from './cffi';
import { TLSClientException } from './exceptions';
import { Response } from './response';
import { CookieJar } from 'tough-cookie';
import { randomUUID } from 'crypto';
import { __version__, } from './__version__';
class Session {
    sessionId;
    headers;
    proxy;
    params;
    cookies;
    sessionOptions;
    clientIdentifier;
    ja3string;
    h2Settings;
    h2SettingsOrder;
    supportedSignatureAlgorithms;
    supportedVersions;
    keyShareCurves;
    certCompressionAlgo;
    pseudoHeaderOrder;
    connectionFlow;
    priorityFrames;
    headerOrder;
    headerPriority;
    randomTlsExtensionOrder;
    forceHttp1;
    constructor(options) {
        this.sessionId = randomUUID();
        this.headers = {
            'User-Agent': `tls-client/${__version__}`,
            'Accept-Encoding': 'gzip, deflate, br',
            'Accept': '*/*',
            'Connection': 'keep-alive',
        };
        this.proxy = '';
        this.params = {};
        this.cookies = new CookieJar();
        this.sessionOptions = options;
        this.clientIdentifier = options?.clientIdentifier;
        this.ja3string = options?.ja3string;
        this.h2Settings = options?.h2Settings;
        this.h2SettingsOrder = options?.h2SettingsOrder;
        this.supportedSignatureAlgorithms = options?.supportedSignatureAlgorithms;
        this.supportedVersions = options?.supportedVersions;
        this.keyShareCurves = options?.keyShareCurves;
        this.certCompressionAlgo = options?.certCompressionAlgo;
        this.pseudoHeaderOrder = options?.pseudoHeaderOrder;
        this.connectionFlow = options?.connectionFlow;
        this.priorityFrames = options?.priorityFrames;
        this.headerOrder = options?.headerOrder;
        this.headerPriority = options?.headerPriority;
        this.randomTlsExtensionOrder = options?.randomTlsExtensionOrder || false;
        this.forceHttp1 = options?.forceHttp1 || false;
    }
    ;
    async executeRequest(method, url, options) {
        if (options?.params) {
            url += `?${new URLSearchParams(options.params).toString()}`;
        }
        let requestBody;
        let contentType;
        if (options?.json) {
            requestBody = JSON.stringify(options.json);
            contentType = 'application/json';
        }
        else if (options?.data) {
            requestBody = new URLSearchParams(Object.entries(options.data)).toString();
            contentType = 'application/x-www-form-urlencoded';
        }
        if (contentType) {
            this.headers['Content-Type'] = contentType;
        }
        let headers = this.headers;
        if (options?.headers) {
            for (const [headerKey, headerValue] of Object.entries(options.headers)) {
                this.headers[headerKey] = headerValue;
            }
            headers = this.headers;
        }
        let cookies = this.cookies;
        if (options?.cookies) {
            for (const [cookieKey, cookieValue] of Object.entries(options.cookies)) {
                await this.cookies.setCookie(`${cookieKey}=${cookieValue}`, url);
            }
            cookies = this.cookies;
        }
        headers['Cookie'] = await cookies.getCookieString(url);
        let proxy = this.proxy;
        if (options?.proxy) {
            proxy = options.proxy;
        }
        const isByteRequest = false;
        const requestPayload = {
            sessionId: this.sessionId,
            followRedirects: options?.allowRedirects || false,
            forceHttp1: this.forceHttp1,
            headers: headers,
            headerOrder: this.headerOrder,
            insecureSkipVerify: options?.insecureSkipVerify || false,
            isByteRequest: isByteRequest,
            proxyUrl: proxy,
            requestUrl: url,
            requestMethod: method.toLocaleUpperCase(),
            requestBody: requestBody,
            requestCookies: [],
            timeoutSeconds: options?.timeoutSeconds || 30,
        };
        if (Object.keys(this.sessionOptions || {}).length) {
            if (this.clientIdentifier) {
                requestPayload.tlsClientIdentifier = this.clientIdentifier;
                requestPayload.withRandomTLSExtensionOrder = this.randomTlsExtensionOrder;
            }
            else {
                requestPayload.customTlsClient = {
                    ja3String: this.ja3string,
                    h2Settings: this.h2Settings,
                    h2SettingsOrder: this.h2SettingsOrder,
                    supportedSignatureAlgorithms: this.supportedSignatureAlgorithms,
                    supportedVersions: this.supportedVersions,
                    keyShareCurves: this.keyShareCurves,
                    certCompressionAlgo: this.certCompressionAlgo,
                    pseudoHeaderOrder: this.pseudoHeaderOrder,
                    connectionFlow: this.connectionFlow,
                    priorityFrames: this.priorityFrames,
                    headerOrder: this.headerOrder,
                    headerPriority: this.headerPriority,
                };
            }
        }
        else {
            requestPayload.tlsClientIdentifier = 'chrome_108';
            requestPayload.withRandomTLSExtensionOrder = false;
        }
        // Async
        const response = await new Promise((resolve, reject) => request.async(JSON.stringify(requestPayload), (error, response) => error ? reject(error) : resolve(response)));
        // Sync
        // const response = request(JSON.stringify(requestPayload));
        if (!response) {
            throw new TLSClientException('No response received');
        }
        const responseObject = JSON.parse(response);
        if (responseObject.status === 0) {
            throw new TLSClientException(responseObject.body);
        }
        const responseCookieJar = new CookieJar();
        if (responseObject.headers['Set-Cookie'] && Array.isArray(responseObject.headers['Set-Cookie'])) {
            for (const cookie of responseObject.headers['Set-Cookie']) {
                await responseCookieJar.setCookie(cookie, url);
            }
        }
        return new Response(responseObject, responseCookieJar);
    }
    async get(url, options) {
        return this.executeRequest('GET', url, options);
    }
    async post(url, options) {
        return this.executeRequest('POST', url, options);
    }
    async put(url, options) {
        return this.executeRequest('PUT', url, options);
    }
    async delete(url, options) {
        return this.executeRequest('DELETE', url, options);
    }
    async head(url, options) {
        return this.executeRequest('HEAD', url, options);
    }
    async patch(url, options) {
        return this.executeRequest('PATCH', url, options);
    }
    async options(url, options) {
        return this.executeRequest('OPTIONS', url, options);
    }
}
export { Session };
